// The following comment is required to instruct analyzers to skip this file
// <auto-generated/>

#if FEATURE_TASK
#if (NETCOREAPP && !NET6_0_OR_GREATER) || (NET45_OR_GREATER) || (NETSTANDARD)
#nullable enable
// ReSharper disable RedundantUsingDirective
// ReSharper disable CheckNamespace
// ReSharper disable InconsistentNaming
// ReSharper disable PartialTypeWithSinglePart

using System;
using System.Threading;
using System.Threading.Tasks;

internal static partial class PolyfillExtensions
{
    extension(Task task)
    {
        // https://learn.microsoft.com/dotnet/api/system.threading.tasks.task.waitasync#system-threading-tasks-task-waitasync(system-timespan-system-threading-cancellationtoken)
        public async Task WaitAsync(TimeSpan timeout, CancellationToken cancellationToken)
        {
            var cancellationTask = Task.Delay(timeout, cancellationToken);
            var finishedTask = await Task.WhenAny(task, cancellationTask).ConfigureAwait(false);

            // Finalize and propagate exceptions
            await finishedTask.ConfigureAwait(false);

            if (finishedTask == cancellationTask)
                throw new TimeoutException("The operation has timed out.");
        }

        // https://learn.microsoft.com/dotnet/api/system.threading.tasks.task.waitasync#system-threading-tasks-task-waitasync(system-threading-cancellationtoken)
        public async Task WaitAsync(CancellationToken cancellationToken) =>
            await task.WaitAsync(Timeout.InfiniteTimeSpan, cancellationToken).ConfigureAwait(false);

        // https://learn.microsoft.com/dotnet/api/system.threading.tasks.task.waitasync#system-threading-tasks-task-waitasync(system-timespan)
        public async Task WaitAsync(TimeSpan timeout) =>
            await task.WaitAsync(timeout, CancellationToken.None).ConfigureAwait(false);
    }

    extension<T>(Task<T> task)
    {
        // https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1.waitasync#system-threading-tasks-task-1-waitasync(system-timespan-system-threading-cancellationtoken)
        public async Task<T> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken)
        {
            var cancellationTask = Task.Delay(timeout, cancellationToken);
            var finishedTask = await Task.WhenAny(task, cancellationTask).ConfigureAwait(false);

            // Finalize and propagate exceptions
            await finishedTask.ConfigureAwait(false);

            if (finishedTask == cancellationTask)
                throw new TimeoutException("The operation has timed out.");

            // If the exception is not thrown, we can safely assume that the main task is completed
            return task.Result;
        }

        // https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1.waitasync#system-threading-tasks-task-1-waitasync(system-threading-cancellationtoken)
        public async Task<T> WaitAsync(CancellationToken cancellationToken) =>
            await task.WaitAsync(Timeout.InfiniteTimeSpan, cancellationToken).ConfigureAwait(false);

        // https://learn.microsoft.com/dotnet/api/system.threading.tasks.task-1.waitasync#system-threading-tasks-task-1-waitasync(system-timespan)
        public async Task<T> WaitAsync(TimeSpan timeout) =>
            await task.WaitAsync(timeout, CancellationToken.None).ConfigureAwait(false);
    }
}
#endif
#endif
